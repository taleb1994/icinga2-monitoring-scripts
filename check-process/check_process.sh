#!/bin/bash
export LC_ALL=C # Ensures consistent locale settings for command output parsing

# Process Status Monitoring Script
# This script checks the status of specified systemd services or Kubernetes pods.
# It verifies if services are enabled, checks versions, and for pods,
# monitors restart counts and reports on previous container states.

set -euo pipefail # Exit on error, undefined vars, pipe failures

# >>> Exit Codes for Icinga <<< #
readonly STATE_OK=0
readonly STATE_WARNING=1
readonly STATE_CRITICAL=2
readonly STATE_UNKNOWN=3

# >>> Script Metadata <<< #
readonly PROGRAM_NAME=$(basename "$0")

# >>> Global Data Structures <<< #
declare -g PROCESS_NAME=""
declare -g OS_INFO=""

# >>> Core Functions <<< #

# Function: print_help
# Displays the script's usage instructions and argument details.
# Exits with STATE_UNKNOWN after printing help.
print_help() {
    cat << EOF
===
This plugin checks the status of a given service (systemd or Kubernetes pod).

Usage:
    ${PROGRAM_NAME} -p <process_name>

Arguments:
    -p, --process   The name of the process/service to check.
                    Supported: k3s, rke2-server, rke2-agent, kafka, mongodb

Options:
    -h, --help      Show this help message.

Examples:
    ${PROGRAM_NAME} -p k3s
    ${PROGRAM_NAME} --process kafka
===
EOF
    exit $STATE_UNKNOWN
}

# Function: get_os_info
# Fetches the operating system's "PRETTY_NAME" from /etc/os-release.
get_os_info() {
    if [[ -f /etc/os-release ]]; then
        source /etc/os-release
        OS_INFO="$PRETTY_NAME"
    else
        OS_INFO="N/A"
    fi
}

# Function: check_systemd_service
# Checks if a systemd service is enabled.
# Parameters:
#   $1: The name of the systemd service.
# Returns:
#   0 if enabled, 1 if not enabled.
check_systemd_service() {
    local service_name="$1"
    if systemctl is-enabled "$service_name" &> /dev/null; then
        return 0 # Service is enabled
    else
        return 1 # Service is not enabled
    fi
}

# Function: check_certificate_expiration
# Checks if a certificate will expire within the next 90 days.
# Parameters:
#   $1: Path to the certificate report text file generated by k3s/rke2 
#		and saved to /tmp/rke2-certificates.txt or /tmp/k3s-certificates.txt
#		to extract the infos out of it using regex
# Prints a warning message if the certificate is expiring soon.
check_certificate_expiration() {
    local cert_file="$1"
    local exit_code=$STATE_OK
    
    # Use OpenSSL to get certificate expiration date
    local exp_date
    exp_date=$(openssl x509 -in "$cert_file" -noout -dates 2>/dev/null | grep "notAfter" | cut -d= -f2)
    
    if [[ -n "$exp_date" ]]; then
        # Convert OpenSSL date format (Jan 22 12:01:58 2026 GMT) to standard format
        local exp_date_std=$(date -d "$exp_date" "+%Y-%m-%d" 2>/dev/null)
        
        if [[ -n "$exp_date_std" ]]; then
            # Calculate the difference in seconds between expiration date and now.
            local exp_seconds=$(date -d "$exp_date_std" +%s)
            local now_seconds=$(date +%s)
            local seconds_until_expiry=$((exp_seconds - now_seconds))
            local ninety_days_in_seconds=$((90 * 86400))

            if [[ "$seconds_until_expiry" -lt "$ninety_days_in_seconds" ]]; then
                echo "WARNING: Certificate $cert_file expires on $exp_date_std and needs rotation soon."
                exit_code=$STATE_WARNING
            else
                echo "OK: Certificate $cert_file expires on $exp_date_std."
            fi
        else
            echo "WARNING: Could not parse certificate expiration date: $exp_date"
            exit_code=$STATE_WARNING
        fi
    else
        echo "WARNING: Could not determine certificate expiration date for $cert_file."
        exit_code=$STATE_WARNING
    fi
    return $exit_code
}
# Function: check_k8s_pod
# Checks the status of a Kubernetes pod.
# Parameters:
#   $1: The application label for the pod (e.g., "kafka", "mongodb").
check_k8s_pod() {
    local app_label="$1"
    local final_exit_code=$STATE_OK
    local pod_info
    
    # Fetch pod details in a single call
    pod_info=$(kubectl get pods -A -l "app=${app_label}" -o jsonpath='{range .items[*]}{.metadata.namespace}{" "}{.metadata.name}{" "}{.status.containerStatuses[0].restartCount}{" "}{.spec.containers[0].image}{" "}{.status.phase}{"\n"}{end}' 2>/dev/null)

    if [[ -z "$pod_info" ]]; then
        echo "CRITICAL: Pod with label app=${app_label} not found."
        return $STATE_CRITICAL
    fi

    while read -r namespace pod_name restart_count image phase; do
        echo -e "\nINFO: Found pod '$pod_name' in namespace '$namespace'."
        echo "Version (Image): $image"
        echo "Status: $phase"

        # Check if pod is running
        if [[ "$phase" != "Running" ]]; then
            echo "WARNING: Pod '$pod_name' is not in a Running state (current: $phase)."
            final_exit_code=$STATE_WARNING
        fi

        # Check restart count
        echo "Restart Count: $restart_count"
        if (( restart_count > 8 )); then
            # High restart count detected. Check the timestamp of the last restart.
            local last_restart_time_str
            last_restart_time_str=$(kubectl get pod -n "$namespace" "$pod_name" -o jsonpath='{.status.containerStatuses[0].lastState.terminated.finishedAt}' 2>/dev/null)

            if [[ -n "$last_restart_time_str" ]]; then
                # Convert timestamp and current time to seconds for comparison
                local last_restart_sec
                last_restart_sec=$(date -d "$last_restart_time_str" +%s)
                local current_time_sec
                current_time_sec=$(date +%s)
                
                local age_in_seconds=$((current_time_sec - last_restart_sec))
                local two_days_in_seconds=$((2 * 24 * 60 * 60))

                if (( age_in_seconds < two_days_in_seconds )); then
                    # The last restart was recent, so this is a concern.
                    echo "WARNING: Restart count ($restart_count) is high and the last restart was less than 2 days ago."
                    final_exit_code=$STATE_WARNING
                else
                    # The pod has been stable for a while, so we can assume the issue is resolved.
                    echo "INFO: Restart count ($restart_count) is high, but the pod has been stable for more than 2 days."
                fi
            else
                # If we can't get the last restart time for a pod with many restarts, it's safer to warn.
                echo "WARNING: Restart count ($restart_count) is high, but the last restart time could not be determined."
                final_exit_code=$STATE_WARNING
            fi
        fi
        
        # Provide context for any restart count greater than 1 and lesser than 8
        if (( restart_count > 1 )); then
            echo -e "\nINFO: Restart count is greater than 1. Fetching last state report..."
            local last_state_report
            last_state_report=$(kubectl describe pod -n "$namespace" "$pod_name" | grep -A 6 "Last State" | awk '{$1=$1; print}')
            echo "--- Last State Report for $pod_name ---"
            echo "$last_state_report"
            echo "------------------------------------"
        fi
    done <<< "$pod_info"

    return $final_exit_code
}

# --- Process Specific Check Functions ---

check_k3s() {
    echo "Service: k3s"
    local exit_code=$STATE_OK

    if ! check_systemd_service k3s; then
        echo "WARNING: k3s service is not enabled."
        exit_code=$STATE_WARNING
    else
        echo "OK: k3s service is enabled."
    fi

    local version
    version=$(k3s --version 2>/dev/null | grep -oP 'v\d+\.\d+\.\d+' || echo "N/A")
    echo "Version: $version"

    local cert_file="/tmp/k3s-certificates.txt"
    if k3s certificate check > "$cert_file" 2>&1; then
        check_certificate_expiration "$cert_file"
        # Capture exit code from cert check to potentially elevate script exit code
        local cert_exit_code=$?
        if (( cert_exit_code > exit_code )); then
            exit_code=$cert_exit_code
        fi
    else
        echo "WARNING: Could not check k3s certificates."
        exit_code=$STATE_WARNING
    fi
    rm -f "$cert_file"
    return $exit_code
}

check_rke2_server() {
    echo "Service: rke2-server"
    local exit_code=$STATE_OK

    if ! check_systemd_service rke2-server; then
        echo "WARNING: rke2-server service is not enabled."
        exit_code=$STATE_WARNING
    else
        echo "OK: rke2-server service is enabled."
    fi

    local version
    version=$(rke2 --version 2>/dev/null | grep -oP 'v\d+\.\d+\.\d+' || echo "N/A")
    echo "Version: $version"

    # Check kube-apiserver client certificate using OpenSSL
    local cert_file="/var/lib/rancher/rke2/server/tls/client-kube-apiserver.crt"
    
    if [[ -f "$cert_file" ]]; then
        check_certificate_expiration "$cert_file"
        local cert_exit_code=$?
        if (( cert_exit_code > exit_code )); then
            exit_code=$cert_exit_code
        fi
    else
        echo "WARNING: Certificate file $cert_file not found."
        exit_code=$STATE_WARNING
    fi
    
    return $exit_code
}

check_rke2_agent() {
    echo "Service: rke2-agent"
    local exit_code=$STATE_OK

    if ! check_systemd_service rke2-agent; then
        echo "WARNING: rke2-agent service is not enabled."
        exit_code=$STATE_WARNING
    else
        echo "OK: rke2-agent service is enabled."
    fi

    local version
    version=$(rke2 --version 2>/dev/null | grep -oP 'v\d+\.\d+\.\d+' || echo "N/A")
    echo "Version: $version"
    
    # Agent does not have its own cert check command in the same way, depends on server.
    # This check is often sufficient from the server side.
    echo -e "\nINFO: Certificate checks for rke2-agent are managed by the rke2-server."
    return $exit_code
}

check_kafka() {
    echo "Service: kafka"
    # Detect if it's a systemd service or k8s pod
    if systemctl list-units --type=service | grep -q "kafka.service"; then
        echo -e "\nINFO: Detected Kafka running as a systemd service."
        local exit_code=$STATE_OK
        if ! check_systemd_service kafka; then
            echo "WARNING: kafka service is not enabled."
            exit_code=$STATE_WARNING
        else
            echo "OK: kafka service is enabled."
        fi
        local version
        # This path might vary, adjust if necessary
        if [[ -x "/opt/kafka/bin/kafka-topics.sh" ]]; then
             version=$(/opt/kafka/bin/kafka-topics.sh --version | awk '{print $1}')
        else
            version="N/A (kafka-topics.sh not found)"
        fi
        echo "Version: $version"
        return $exit_code
    elif command -v kubectl &> /dev/null && kubectl get pod -A -l "app=kafka" &> /dev/null; then
        echo -e "\nINFO: Detected Kafka running as a Kubernetes pod."
        check_k8s_pod "kafka"
        return $?
    else
        echo "UNKNOWN: Could not determine run type for Kafka (systemd or Kubernetes)."
        return $STATE_UNKNOWN
    fi
}

check_mongodb() {
    echo "Service: mongod"
    # Detect if it's a systemd service or k8s pod
    if systemctl list-units --type=service | grep -q "mongod.service"; then
        echo -e "\nINFO: Detected MongoDB running as a systemd service."
        local exit_code=$STATE_OK
        if ! check_systemd_service mongod; then
            echo "WARNING: mongod service is not enabled."
            exit_code=$STATE_WARNING
        else
            echo "OK: mongod service is enabled."
        fi
        local version
        version=$(mongod --version 2>/dev/null | grep "db version" | grep -oP 'v\d+\.\d+\.\d+' || echo "N/A")
        echo "Version: $version"
        return $exit_code
    elif command -v kubectl &> /dev/null && kubectl get pod -A -l "app=mongodb" &> /dev/null; then
        echo -e "\nINFO: Detected MongoDB running as a Kubernetes pod."
        check_k8s_pod "mongodb"
        return $?
    else
        echo "UNKNOWN: Could not determine run type for MongoDB (systemd or Kubernetes)."
        return $STATE_UNKNOWN
    fi
}

# >>> Main Execution Block <<< #
main() {
    if [[ $# -eq 0 ]]; then
        print_help
    fi

    # Parse command line arguments.
    while [[ $# -gt 0 ]]; do
        case $1 in
            -p|--process)
                PROCESS_NAME="$2"
                shift 2
                ;;
            -h|--help)
                print_help
                ;;
            *)
                echo "ERROR: Unknown argument: $1" >&2
                print_help
                ;;
        esac
    done

    if [[ -z "$PROCESS_NAME" ]]; then
        echo "ERROR: Process name must be provided with -p or --process." >&2
        print_help
    fi

    get_os_info
    echo "OS: $OS_INFO"
    echo "================================================="

    local final_status=$STATE_UNKNOWN
    case "$PROCESS_NAME" in
        k3s)
            check_k3s
            final_status=$?
            ;;
        rke2-server)
            check_rke2_server
            final_status=$?
            ;;
        rke2-agent)
            check_rke2_agent
            final_status=$?
            ;;
        kafka)
            check_kafka
            final_status=$?
            ;;
        mongodb)
            check_mongodb
            final_status=$?
            ;;
        *)
            echo "ERROR: Unsupported process name '$PROCESS_NAME'." >&2
            print_help
            ;;
    esac
    
    echo "================================================="
    case "$final_status" in
        0) echo "Final Status: OK" ;;
        1) echo "Final Status: WARNING" ;;
        2) echo "Final Status: CRITICAL" ;;
        *) echo "Final Status: UNKNOWN" ;;
    esac
    exit $final_status
}

# Execute main function only if the script is run directly.
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
